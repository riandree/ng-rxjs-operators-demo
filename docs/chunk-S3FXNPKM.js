import{a as T}from"./chunk-7OOZIZJO.js";import{a as E,b as H}from"./chunk-RQIQXLRU.js";import{$a as s,B as b,G as j,Ia as x,P as p,Qa as _,Za as t,_a as a,ab as k,cb as u,eb as v,fb as n,ga as y,j as h,ka as w,la as f,lb as C,r as d,y as S,z as m}from"./chunk-FMOREFH7.js";var F=(()=>{let i=class i{constructor(r){this.description=`
      This example has two 'interval(1000)' Observables for each of which errors
      are handled differently.
    `,this.firstErrorSubject=new h,this.secondErrorSubject=new h,r.println(`Welcome to 'catchError'
`),m(1e3).pipe(p(this.firstErrorSubject),b(e=>{throw r.println(`
catchError Handler catched error :`+e),r.println("A new Error() is thrown now which will not be handled and will therefore END this observable"),r.println("and render the button you just pressed disfunctional."),r.println(`NOW : throw new Error("Error thrown from within 'catchError' : "+e);`),r.println(`Have a look at the browser console to see the unhandled error there.
`),new Error("Error thrown from within 'catchError' : "+e)}),E()).subscribe(e=>{r.println("from throwing Observable",e)}),m(1e3).pipe(p(this.secondErrorSubject),d(e=>e),b(e=>(r.println(`
catchError Handler catched error :`+e),r.println("A new Observable is returned that replaces the old one."),r.println("The new observable will emit 10 events at an interval of 0.1s"),r.println("After the 10 Events have been emitted the observable will complete."),S(0,100).pipe(j(10),d(o=>` ${o+1}/10 event from new observable after catching error ${e}`)))),E()).subscribe(e=>{r.println("from error transforming Observable",e)})}};i.\u0275fac=function(e){return new(e||i)(x(H))},i.\u0275cmp=y({type:i,selectors:[["rxd-catch-error"]],standalone:!0,features:[C],decls:21,vars:1,consts:[["title","catchError",3,"desc"],["type","text"],["firstMsg",""],[3,"click"],["secondMsg",""],[2,"background-color","yellow"]],template:function(e,o){if(e&1){let g=k();s(0,"rxd-demo-header",0),t(1,"p")(2,"label"),n(3," The first observable stream handles errors by catching the error and throwing a new Error-Object by means of the Javascript 'throw' statement from within the 'catchError' Handler. "),t(4,"p"),s(5,"input",1,2),t(7,"button",3),u("click",function(){w(g);let c=v(6);return f(o.firstErrorSubject.error(c.value))}),n(8,"inject Error into first reactive stream"),a()(),n(9," This error thrown from within the catchError-Handler will become an rxjs error-event and could be handled by catchError-handlers further down the pipeline but since the are no other error-handlers it will be catched by rxjs resulting in the observable stream being ended and the error logged on the browser console. "),a()(),s(10,"hr"),t(11,"p")(12,"label"),n(13," The second observable stream handles errors by catching the error and returning a new observable. In this case the new observable will emit 10 events at an interval of 0.1s and complete afterwards. "),t(14,"p"),s(15,"input",1,4),t(17,"button",3),u("click",function(){w(g);let c=v(16);return f(o.secondErrorSubject.error(c.value))}),n(18,"inject Error into second reactive stream"),a()()()(),t(19,"p",5),n(20,` Reload page to restart the observables.
`),a()}e&2&&_("desc",o.description)},dependencies:[T],encapsulation:2});let l=i;return l})();export{F as CatchErrorComponent};
